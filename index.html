<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Ruby under a microscope</title>
		<meta name="description" content="Ruby under a microscope introduction">
		<meta name="author" content="Bachue Zhou">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Ruby 2.0</h1>
					<h3>Under a Microscope</h3>
					<p>
						<small>Created by <a href="http://bachue.is-programmer.com">Bachue</a> / <a href="http://twitter.com/iBachue">@iBachue</a></small>
					</p>
					<aside class="notes">
						I'll introduce some points in this book to you.
					</aside>
				</section>

				<section>
					<a href="http://patshaughnessy.net/ruby-under-a-microscope"><img src="img/cover.png" alt="cover of the book" /></a>
					<aside class="notes">
						This book is available to buy on <a href="http://www.nostarch.com/rum">http://www.nostarch.com/rum</a>, price is $31.95.
					</aside>
				</section>

				<section>
					<img src="img/sanya.jpg" />
				</section>

				<section>
					<h3>Who is this book for?</h3>
					<ul>
						<li>Ruby programmer</li>
						<li>No C programming knowledge is required</li>
					</ul>
                    <aside class="notes">
                        <p>No Ruby basis explaination in these slides!</p>
                        <p>No C code shown in these slides!</p>
                    </aside>
				</section>

                <section>
                    <h3>Agenda</h3>
                    <ul>
                        <li>Overview</li>
                        <li>Tokenize</li>
                        <li>Parsing</li>
                        <li>Compilation</li>
                        <li>Execution as double stack machine</li>
                        <li>Control Structures</li>
                        <li>Objects &amp; Class</li>
                        <li>Method Lookup &amp; Constant Lookup</li>
                        <li>Closure &amp; Binding</li>
                        <li>GC</li>
                    </ul>
                </section>

				<section>
					<section>
						<h1>Overview</h1>
						<img src="img/overview.png" />
					</section>
					<section>
						<h1>JRuby</h1>
						<img src="img/jruby-overview.png" />
					</section>
					<section>
						<h1>Rubinius</h1>
						<img src="img/rubinius-overview.png" />
					</section>
				</section>

				<section>
					<section>
						<h1>Tokenize</h1>
						<pre><code class="ruby">
10.times do |n|
  puts n
end
						</code></pre>
					</section>
					<section>
						<h3>Before</h3>
						<img src="img/before-tokenize.png" />
					</section>
					<section>
						<h3>After</h3>
						<img src="img/after-tokenize.png" />
					</section>
					<section>
						<h3>parser_yylex in parse.y</h3>
						<h4>Keywords: defs/keywords</h4>
						<aside class="notes">
							<p>ruby/parse.y:6693 in `parser_yylex'</p>
							<p>start from line 6968: <code>switch (c = nextc())</code></p>
							<p>keywords: rb_reserved_word, defs/keywords => lex.c</p>
						</aside>
					</section>
					<section>
						<h3>Ripper.lex</h3>
						<pre><code class="ruby">
require 'ripper'
require 'pp'
code = &lt;&lt;STR
  10.times do |n|
    puts n
  end
STR
pp Ripper.lex(code)
						</code></pre>
						<aside class="notes">
							Ripper allows you to call the same tokenization and parsing code that Ruby uses to process text from code files.
						</aside>
					</section>
					<section>
						<pre><code class="ruby" style="max-height: inherit;">
[[[1, 0], :on_sp, "  "],
 [[1, 2], :on_int, "10"],
 [[1, 4], :on_period, "."],
 [[1, 5], :on_ident, "times"],
 [[1, 10], :on_sp, " "],
 [[1, 11], :on_kw, "do"],
 [[1, 13], :on_sp, " "],
 [[1, 14], :on_op, "|"],
 [[1, 15], :on_ident, "n"],
 [[1, 16], :on_op, "|"],
 [[1, 17], :on_ignored_nl, "\n"],
 [[2, 0], :on_sp, "    "],
 [[2, 4], :on_ident, "puts"],
 [[2, 8], :on_sp, " "],
 [[2, 9], :on_ident, "n"],
 [[2, 10], :on_nl, "\n"],
 [[3, 0], :on_sp, "  "],
 [[3, 2], :on_kw, "end"],
 [[3, 5], :on_nl, "\n"]]
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Phasing</h1>
						<h2>LALR</h2>
						<h2>Bison</h2>
					</section>
					<section>
						<h3>Spanish => English Example</h3>
						<pre><code class="asciidoc">
Me gusta el Ruby. => I Like Ruby.
Le gusta el Ruby. => She likes Ruby.
						</code></pre>
					</section>
					<section>
						<h3>Bison/Yacc grammar</h3>
						<pre><code class="asciidoc">
SpanishPhrase: VerbAndObject el ruby {
  printf("%s Ruby\n", $1);
};
VerbAndObject: SheLikes | ILike {
  $$ = $1;
};
SheLikes: le gusta {
  $$ = "She likes";
}
ILike: me gusta {
  $$ = "I like";
}
						</code></pre>
					</section>
					<section>
						<h3>Simplified Steps</h3>
						<table style="margin: auto;">
							<tr>
								<th>Grammar Rule Stack</th>
								<th>Tokens</th>
								<th>Action</th>
							</tr>
							<tr>	
								<td></td>
								<td>le gusta el ruby</td>
								<td></td>
							</tr>	
							<tr>	
								<td>le</td>
								<td>gusta el ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>le gusta</td>
								<td>el ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>SheLikes</td>
								<td>el ruby</td>
								<td>Reduce</td>
							</tr>	
							<tr>	
								<td>VerbAndObject</td>
								<td>el ruby</td>
								<td>Reduce</td>
							</tr>	
							<tr>	
								<td>VerbAndObject el</td>
								<td>ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>VerbAndObject el ruby</td>
								<td></td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>SpanishPhrase</td>
								<td></td>
								<td>Match</td>
							</tr>	
						</table>
						<aside class="notes">
							LALR Goto Table
						</aside>
					</section>
					<section>
						<h3>parse.y</h3>
						<aside class="notes">
							<p>parse.y:860</p>
							<a target="_blank" href="/img/ruby-1-4-bnf.pdf">BNF Syntax of Ruby 1.4</a>
						</aside>
					</section>
					<section>
						<h3>ruby -y</h3>
						<pre><code class="ruby">
10.times do |n|
  puts n
end
						</code></pre>
					</section>
					<section>
						<pre><code class="asciidoc">
Starting parse
Entering state 0
Reducing stack by rule 1 (line 782):
-> $$ = nterm @1 ()
Stack now 0
Entering state 2
Reading a token: Next token is token tINTEGER ()
Shifting token tINTEGER ()
Entering state 41
Reducing stack by rule 470 (line 4255):
   $1 = token tINTEGER ()
-> $$ = nterm numeric ()
Stack now 0 2
Entering state 104
Reducing stack by rule 428 (line 3830):
   $1 = nterm numeric ()
-> $$ = nterm literal ()
Stack now 0 2
Entering state 94
Reducing stack by rule 270 (line 2616):
   $1 = nterm literal ()
-> $$ = nterm primary ()
Stack now 0 2
Entering state 80
Reading a token: Next token is token '.' ()
Reducing stack by rule 329 (line 3071):
   $1 = nterm primary ()
-> $$ = nterm primary_value ()
Stack now 0 2
Entering state 81
Next token is token '.' ()
Shifting token '.' ()
Entering state 336
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 533
Reading a token: Next token is token keyword_do ()
Reducing stack by rule 550 (line 4823):
   $1 = token tIDENTIFIER ()
-> $$ = nterm operation2 ()
Stack now 0 2 81 336
Entering state 538
Next token is token keyword_do ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 81 336 538
Entering state 676
Reducing stack by rule 246 (line 2426):
   $1 = nterm none ()
-> $$ = nterm opt_paren_args ()
Stack now 0 2 81 336 538
Entering state 674
Reducing stack by rule 404 (line 3635):
   $1 = nterm primary_value ()
   $2 = token '.' ()
   $3 = nterm operation2 ()
   $4 = nterm opt_paren_args ()
-> $$ = nterm method_call ()
Stack now 0 2
Entering state 93
Next token is token keyword_do ()
Shifting token keyword_do ()
Entering state 380
Reducing stack by rule 414 (line 3735):
-> $$ = nterm @28 ()
Stack now 0 2 93 380
Entering state 576
Reading a token: Next token is token '|' ()
Shifting token '|' ()
Entering state 653
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 761
Reading a token: Next token is token '|' ()
Reducing stack by rule 518 (line 4543):
   $1 = token tIDENTIFIER ()
-> $$ = nterm f_norm_arg ()
Stack now 0 2 93 380 576 653
Entering state 636
Reducing stack by rule 519 (line 4550):
   $1 = nterm f_norm_arg ()
-> $$ = nterm f_arg_item ()
Stack now 0 2 93 380 576 653
Entering state 637
Reducing stack by rule 521 (line 4578):
   $1 = nterm f_arg_item ()
-> $$ = nterm f_arg ()
Stack now 0 2 93 380 576 653
Entering state 765
Next token is token '|' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 653 765
Entering state 748
Reducing stack by rule 537 (line 4723):
   $1 = nterm none ()
-> $$ = nterm opt_f_block_arg ()
Stack now 0 2 93 380 576 653 765
Entering state 850
Reducing stack by rule 372 (line 3377):
   $1 = nterm f_arg ()
   $2 = nterm opt_f_block_arg ()
-> $$ = nterm block_param ()
Stack now 0 2 93 380 576 653
Entering state 763
Next token is token '|' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 653 763
Entering state 770
Reducing stack by rule 385 (line 3479):
   $1 = nterm none ()
-> $$ = nterm opt_bv_decl ()
Stack now 0 2 93 380 576 653 763
Entering state 847
Next token is token '|' ()
Shifting token '|' ()
Entering state 905
Reducing stack by rule 384 (line 3468):
   $1 = token '|' ()
   $2 = nterm block_param ()
   $3 = nterm opt_bv_decl ()
   $4 = token '|' ()
-> $$ = nterm block_param_def ()
Stack now 0 2 93 380 576
Entering state 655
Reducing stack by rule 381 (line 3444):
   $1 = nterm block_param_def ()
-> $$ = nterm opt_block_param ()
Stack now 0 2 93 380 576
Entering state 716
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 35
Reading a token: Next token is token tIDENTIFIER ()
Reducing stack by rule 547 (line 4818):
   $1 = token tIDENTIFIER ()
-> $$ = nterm operation ()
Stack now 0 2 93 380 576 716
Entering state 110
Next token is token tIDENTIFIER ()
Reducing stack by rule 258 (line 2499):
-> $$ = nterm @7 ()
Stack now 0 2 93 380 576 716 110
Entering state 219
Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 35
Reading a token: Next token is token '\n' ()
Reducing stack by rule 474 (line 4275):
   $1 = token tIDENTIFIER ()
-> $$ = nterm user_variable ()
Stack now 0 2 93 380 576 716 110 219
Entering state 209
Next token is token '\n' ()
Reducing stack by rule 486 (line 4291):
   $1 = nterm user_variable ()
-> $$ = nterm var_ref ()
Stack now 0 2 93 380 576 716 110 219
Entering state 107
Reducing stack by rule 276 (line 2622):
   $1 = nterm var_ref ()
-> $$ = nterm primary ()
Stack now 0 2 93 380 576 716 110 219
Entering state 80
Next token is token '\n' ()
Reducing stack by rule 239 (line 2375):
   $1 = nterm primary ()
-> $$ = nterm arg ()
Stack now 0 2 93 380 576 716 110 219
Entering state 203
Next token is token '\n' ()
Reducing stack by rule 240 (line 2381):
   $1 = nterm arg ()
-> $$ = nterm arg_value ()
Stack now 0 2 93 380 576 716 110 219
Entering state 204
Next token is token '\n' ()
Reducing stack by rule 263 (line 2531):
   $1 = nterm arg_value ()
-> $$ = nterm args ()
Stack now 0 2 93 380 576 716 110 219
Entering state 207
Next token is token '\n' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 716 110 219 207
Entering state 398
Reducing stack by rule 262 (line 2525):
   $1 = nterm none ()
-> $$ = nterm opt_block_arg ()
Stack now 0 2 93 380 576 716 110 219 207
Entering state 397
Reducing stack by rule 254 (line 2463):
   $1 = nterm args ()
   $2 = nterm opt_block_arg ()
-> $$ = nterm call_args ()
Stack now 0 2 93 380 576 716 110 219
Entering state 409
Reducing stack by rule 259 (line 2499):
   $1 = nterm @7 ()
   $2 = nterm call_args ()
-> $$ = nterm command_args ()
Stack now 0 2 93 380 576 716 110
Entering state 387
Next token is token '\n' ()
Reducing stack by rule 58 (line 1344):
   $1 = nterm operation ()
   $2 = nterm command_args ()
-> $$ = nterm command ()
Stack now 0 2 93 380 576 716
Entering state 72
Next token is token '\n' ()
Reducing stack by rule 51 (line 1297):
   $1 = nterm command ()
-> $$ = nterm command_call ()
Stack now 0 2 93 380 576 716
Entering state 70
Reducing stack by rule 44 (line 1249):
   $1 = nterm command_call ()
-> $$ = nterm expr ()
Stack now 0 2 93 380 576 716
Entering state 69
Next token is token '\n' ()
Reducing stack by rule 41 (line 1225):
   $1 = nterm expr ()
-> $$ = nterm stmt ()
Stack now 0 2 93 380 576 716
Entering state 245
Next token is token '\n' ()
Reducing stack by rule 14 (line 933):
   $1 = nterm stmt ()
-> $$ = nterm stmts ()
Stack now 0 2 93 380 576 716
Entering state 244
Next token is token '\n' ()
Shifting token '\n' ()
Entering state 289
Reducing stack by rule 569 (line 4866):
   $1 = token '\n' ()
-> $$ = nterm term ()
Stack now 0 2 93 380 576 716 244
Entering state 291
Reducing stack by rule 570 (line 4869):
   $1 = nterm term ()
-> $$ = nterm terms ()
Stack now 0 2 93 380 576 716 244
Entering state 433
Reading a token: Next token is token keyword_end ()
Reducing stack by rule 560 (line 4847):
   $1 = nterm terms ()
-> $$ = nterm opt_terms ()
Stack now 0 2 93 380 576 716 244
Entering state 432
Reducing stack by rule 12 (line 913):
   $1 = nterm stmts ()
   $2 = nterm opt_terms ()
-> $$ = nterm compstmt ()
Stack now 0 2 93 380 576 716
Entering state 817
Next token is token keyword_end ()
Shifting token keyword_end ()
Entering state 881
Reducing stack by rule 415 (line 3734):
   $1 = token keyword_do ()
   $2 = nterm @28 ()
   $3 = nterm opt_block_param ()
   $4 = nterm compstmt ()
   $5 = token keyword_end ()
-> $$ = nterm brace_block ()
Stack now 0 2 93
Entering state 382
Reducing stack by rule 298 (line 2781):
   $1 = nterm method_call ()
   $2 = nterm brace_block ()
-> $$ = nterm primary ()
Stack now 0 2
Entering state 80
Reading a token: Next token is token '\n' ()
Reducing stack by rule 239 (line 2375):
   $1 = nterm primary ()
-> $$ = nterm arg ()
Stack now 0 2
Entering state 79
Next token is token '\n' ()
Reducing stack by rule 49 (line 1282):
   $1 = nterm arg ()
-> $$ = nterm expr ()
Stack now 0 2
Entering state 69
Next token is token '\n' ()
Reducing stack by rule 41 (line 1225):
   $1 = nterm expr ()
-> $$ = nterm stmt ()
Stack now 0 2
Entering state 67
Next token is token '\n' ()
Reducing stack by rule 8 (line 855):
   $1 = nterm stmt ()
-> $$ = nterm top_stmt ()
Stack now 0 2
Entering state 66
Reducing stack by rule 5 (line 833):
   $1 = nterm top_stmt ()
-> $$ = nterm top_stmts ()
Stack now 0 2
Entering state 65
Next token is token '\n' ()
Shifting token '\n' ()
Entering state 289
Reducing stack by rule 569 (line 4866):
   $1 = token '\n' ()
-> $$ = nterm term ()
Stack now 0 2 65
Entering state 291
Reducing stack by rule 570 (line 4869):
   $1 = nterm term ()
-> $$ = nterm terms ()
Stack now 0 2 65
Entering state 292
Reading a token: Now at end of input.
Reducing stack by rule 560 (line 4847):
   $1 = nterm terms ()
-> $$ = nterm opt_terms ()
Stack now 0 2 65
Entering state 290
Reducing stack by rule 3 (line 813):
   $1 = nterm top_stmts ()
   $2 = nterm opt_terms ()
-> $$ = nterm top_compstmt ()
Stack now 0 2
Entering state 64
Reducing stack by rule 2 (line 782):
   $1 = nterm @1 ()
   $2 = nterm top_compstmt ()
-> $$ = nterm program ()
Stack now 0
Entering state 1
Now at end of input.
Stack now 0 1
Cleanup: popping nterm program ()
						</code></pre>
					</section>
					<section>
						<h3>Ripper.sexp</h3>
						<pre><code class="ruby">
require 'ripper'
require 'pp'
code = &lt;&lt;STR
  10.times do |n|
    puts n
  end
STR
puts code
pp Ripper.sexp(code)
						</code></pre>
					</section>
					<section>
						<pre><code class="ruby">
[:program,
 [[:method_add_block,
   [:call, [:@int, "10", [1, 3]], :".", [:@ident, "times", [1, 6]]],
   [:do_block,
    [:block_var,
     [:params, [[:@ident, "n", [1, 16]]], nil, nil, nil, nil],
     nil],
    [[:command,
      [:@ident, "puts", [2, 0]],
      [:args_add_block, [[:var_ref, [:@ident, "n", [2, 5]]]], false]]]]]]]
						</code></pre>
					</section>
					<section>
						<h3>ruby --dump parsetree</h3>
						<pre><code class="asciidoc">
@ NODE_SCOPE (line: 3)
+- nd_tbl: (empty)
+- nd_args:
|   (null node)
+- nd_body:
    @ NODE_ITER (line: 1)
    +- nd_iter:
    |   @ NODE_CALL (line: 1)
    |   +- nd_mid: :times
    |   +- nd_recv:
    |   |   @ NODE_LIT (line: 1)
    |   |   +- nd_lit: 10
    |   +- nd_args:
    |       (null node)
    +- nd_body:
        @ NODE_SCOPE (line: 3)
        +- nd_tbl: :n
        +- nd_args:
        |   @ NODE_ARGS (line: 1)
        |   +- nd_frml: 1
        |   +- nd_next:
        |   |   @ NODE_ARGS_AUX (line: 1)
        |   |   +- nd_rest: (null)
        |   |   +- nd_body: (null)
        |   |   +- nd_next:
        |   |       (null node)
        |   +- nd_opt:
        |       (null node)
        +- nd_body:
            @ NODE_FCALL (line: 2)
            +- nd_mid: :puts
            +- nd_args:
                @ NODE_ARRAY (line: 2)
                +- nd_alen: 1
                +- nd_head:
                |   @ NODE_DVAR (line: 2)
                |   +- nd_vid: :n
                +- nd_next:
                    (null node)
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>Compilation</h1>
					</section>
					<section>
						<h3>Ruby 1.8</h3>
						<img src="img/ruby-18-layers.png" />
					</section>
					<section>
						<h3>Ruby 1.9 &amp; 2.0</h3>
						<img src="img/ruby-19-20-layers.png" />
					</section>
					<section>
						<h3>Benchmark</h3>
						<pre><code class="ruby">
i= 0
while i &lt; ARGV[0].to_i
  i += 1
end
						</code></pre>
					</section>
					<section>
						<h3>logarithmic scale</h3>
						<img src="img/ruby-logarithmic-performance.png" />
					</section>
					<section>
						<h3>linear scale</h3>
						<img src="img/ruby-linear-performance.png" />
					</section>
					<section>
						<h3>iseq_compile_each in compile.c</h3>
						<aside class="notes">
							<p>compile.c:6933</p>
						</aside>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code class="ruby">
code = &lt;&lt;-RUBY
  puts 1 + 2
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<h3>Compiled</h3>
						<pre><code class="asciidoc">
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
0000 trace            1                                               (   1)
0002 putself
0003 putobject_OP_INT2FIX_O_1_C_
0004 putobject        2
0006 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
0008 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0010 leave
						</code></pre>
						<aside class="notes">
							Stack machine
						</aside>
					</section>
					<section>
						<h3>Example 2</h3>
						<pre><code class="ruby">
code = &lt;&lt;-RUBY
  10.times do |n|
    puts n
  end
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<h3>Compiled</h3>
						<pre><code class="asciidoc" style="max-height: inherit;">
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
== catch table
| catch type: break  st: 0002 ed: 0006 sp: 0000 cont: 0006
|------------------------------------------------------------------------
0000 trace            1                                               (   1)
0002 putobject        10
0004 send             &lt;callinfo!mid:times, argc:0, block:block in &lt;compiled&gt;&gt;
0006 leave
== disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
== catch table
| catch type: redo   st: 0000 ed: 0009 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0009 sp: 0000 cont: 0009
|------------------------------------------------------------------------
local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
[ 2] n&lt;Arg&gt;
0000 trace            256                                             (   1)
0002 trace            1                                               (   2)
0004 putself
0005 getlocal_OP__WC__0 2
0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0009 trace            512                                             (   3)
0011 leave                                                            (   2)
						</code></pre>
						<aside class="notes">
							Local variable
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Execution</h1>
						<h3>As double stack machine</h3>
					</section>
					<section>
						<h3>rb_control_frame_t</h3>
						<img src="img/rb_control_frame_t-1.png" />
					</section>
					<section>
						<h3>caller</h3>
						<img src="img/rb_control_frame_t-2.png" />
					</section>
					<section>
						<h3>Example</h3>
						<pre><code class="ruby">
10.times do
  puts "The quick brown fox jumps over the lazy dog."
end
						</code></pre>
					</section>
					<section>
						<img src="img/rb_control_frame_t-3.png" />
					</section>
					<section>
						<h3>Local Variable Access</h3>
					</section>
					<section>
						<h3>Environment Pointer</h3>
						<img src="img/local_variable_1.png" />
						<aside class="notes">
							EP = SP - 1
							Special: to track information related to blocks(rb_block_t).
						</aside>
					</section>
					<section>
						<img src="img/local_variable_2.png" />
						<aside class="notes">
							<p>Local variable table is not a table(Just like C)</p>
							<p>svar: pointer to special variable table</p>
							<p>cref: pointer to current lexical scope(designed for *_eval, *_exec methods)</p>
							<p>Method Arguments Are Treated Like Local Variables</p>
						</aside>
					</section>
					<section>
						<h3>Dynamic Variable Access</h3>
						<pre><code class="ruby">
code = &lt;&lt;-RUBY
  def display_string
    str = "Dynamic access."
    10.times do
      puts str
    end
  end
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<pre><code class="asciidoc" style="max-height: inherit;">
== disasm: &lt;RubyVM::InstructionSequence:f@&lt;compiled&gt;&gt;===================
== catch table
| catch type: break  st: 0010 ed: 0014 sp: 0000 cont: 0014
|------------------------------------------------------------------------
local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 2] str
0000 trace            8                                               (   1)
0002 trace            1                                               (   2)
0004 putstring        "Dynamic access."
0006 setlocal_OP__WC__0 2
0008 trace            1                                               (   3)
0010 putobject        10
0012 send             &lt;callinfo!mid:times, argc:0, block:block in f&gt;
0014 trace            16                                              (   6)
0016 leave                                                            (   3)
== disasm: &lt;RubyVM::InstructionSequence:block in f@&lt;compiled&gt;&gt;==========
== catch table
| catch type: redo   st: 0000 ed: 0009 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0009 sp: 0000 cont: 0009
|------------------------------------------------------------------------
0000 trace            256                                             (   3)
0002 trace            1                                               (   4)
0004 putself
0005 getlocal_OP__WC__1 2
0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0009 trace            512                                             (   5)
0011 leave                                                            (   4)
						</code></pre>
					</section>
					<section>
						<img src="img/dynamic_variable.png" />
					</section>
					<section>
						<h3>Special Variable Access</h3>
					</section>
					<section>
						<h3>Guess?</h3>
						<pre><code class="ruby">
str = "The quick brown fox jumped over the lazy dog.\n"
/fox/.match(str)
def search(str)
  /dog/.match(str)
  puts "Value of $&amp; inside method: \#{$&amp;}"
end
search(str)
puts "Value of $&amp; in the top level scope: \#{$&amp;}"
						</code></pre>
						<aside class="notes">
							Guess: What's the answer?
						</aside>
					</section>
					<section>
						<img src="img/special_variable_1.png" />
					</section>
					<section>
						<h3>Guess Again?</h3>
						<pre><code class="ruby">
str = "The quick brown fox jumped over the lazy dog.\n"
/fox/.match(str)
2.times do
  /dog/.match(str)
  puts "Value of $&amp; inside block: \#{$&amp;}"
end
puts "Value of $&amp; in the top level scope: \#{$&amp;}"
						</code></pre>
						<aside class="notes">
							Guess: What's the answer?
						</aside>
					</section>
					<section>
						<img src="img/special_variable_2.png" />
					</section>
					<section>
						<h3>YARV Instruments Definitions</h3>
						<aside class="notes">
							<div>tool/insns2vm.rb</div>
							<div>insns.def</div>
							<div>vm.inc</div>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Control Structures</h1>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code class="ruby">
code = &lt;&lt;-RUBY
  i = 0
  while i &lt; 20
    if i &lt; 10
      puts 'small'
    else
      for j in 0..3
        puts "large \#{j}"
      end
    end
    i += 1
  end
  puts 'done'
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<pre><code class="asciidoc">
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
== catch table
| catch type: break  st: 0035 ed: 0039 sp: 0000 cont: 0039
| catch type: break  st: 0013 ed: 0058 sp: 0000 cont: 0058
| catch type: next   st: 0013 ed: 0058 sp: 0000 cont: 0010
| catch type: redo   st: 0013 ed: 0058 sp: 0000 cont: 0013
|------------------------------------------------------------------------
local table (size: 3, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 3] i          [ 2] j
0000 trace            1                                               (   1)
0002 putobject_OP_INT2FIX_O_0_C_
0003 setlocal_OP__WC__0 3
0005 trace            1                                               (   2)
0007 jump             49
0009 putnil
0010 pop
0011 jump             49
0013 trace            1                                               (   3)
0015 getlocal_OP__WC__0 3
0017 putobject        10
0019 opt_lt           &lt;callinfo!mid:&lt;, argc:1, ARGS_SKIP&gt;
0021 branchunless     33
0023 trace            1                                               (   4)
0025 putself
0026 putstring        "small"
0028 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0030 pop
0031 jump             40                                              (   3)
0033 trace            1                                               (   6)
0035 putobject        0..3
0037 send             &lt;callinfo!mid:each, argc:0, block:block in &lt;compiled&gt;&gt;
0039 pop
0040 trace            1                                               (  10)
0042 getlocal_OP__WC__0 3
0044 putobject_OP_INT2FIX_O_1_C_
0045 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
0047 setlocal_OP__WC__0 3
0049 getlocal_OP__WC__0 3                                             (   2)
0051 putobject        20
0053 opt_lt           &lt;callinfo!mid:&lt;, argc:1, ARGS_SKIP&gt;
0055 branchif         13
0057 putnil
0058 pop
0059 trace            1                                               (  12)
0061 putself
0062 putstring        "done"
0064 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0066 leave
== disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
== catch table
| catch type: redo   st: 0004 ed: 0018 sp: 0000 cont: 0004
| catch type: next   st: 0004 ed: 0018 sp: 0000 cont: 0018
|------------------------------------------------------------------------
local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
[ 2] ?&lt;Arg&gt;
0000 getlocal_OP__WC__0 2                                             (   8)
0002 setlocal_OP__WC__1 2                                             (   6)
0004 trace            256
0006 trace            1                                               (   7)
0008 putself
0009 putobject        "large "
0011 getlocal_OP__WC__1 2
0013 tostring
0014 concatstrings    2
0016 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0018 trace            512                                             (   8)
0020 leave                                                            (   7)
						</code></pre>
					</section>
					<section>
						<h3>Catch table</h3>
						<img src="img/catch_table.png" />
					</section>
				</section>

				<section>
					<section>
						<h1>Objects &amp; Class</h1>
					</section>
					<section>
						<h3>RObject</h3>
						<img src="img/r_object.png" />
						<aside class="notes">
							<p>At the top of the figure is a pointer to the RObject structure. (Internally, Ruby always refers to any value with a VALUE pointer.) Below this pointer, the RObject structure contains an inner RBasic structure and information spe- cific to custom objects. The RBasic sec- tion contains information that all values use: a set of Boolean values called flags that store a variety of internal technical values, and a class pointer called klass.</p>
							<p>The class pointer indicates which class an object is an instance of. In the RObject section, Ruby saves an array of instance variables that each object contains, using numiv, the instance variable count, and ivptr, a pointer to an array of values.</p>
                            <p>RBasic: includes/ruby/ruby.h:747</p>
                            <p>RObject: includes/ruby/ruby.h:762</p>
						</aside>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code class="ruby">
class Mathematician
  attr_accessor :first_name
  attr_accessor :last_name
end

euler = Mathematician.new
euler.first_name = 'Leonhard'
euler.last_name = 'Euler'

euclid = Mathematician.new
euclid.first_name = 'Euclid'
						</code></pre>
					</section>
					<section>
						<img src="img/r_object_example.png" />
					</section>
                    <section>
                        <h3>Instance Variable Access</h3>
                        <img src="img/instance_variable_1.png" />
                        <img src="img/instance_variable_2.png" />
                        <aside class="notes">
                            <ul>
                                <li>In Ruby 1.8, RObject stores instance variables as a hashmap.</li>
                                <li>In Ruby 1.9, RObject just stores values of instance variables in an Array, and RClass stores names of them. Use index to connect them.</li>
                                <li>Instance variable values table will preallocate more space.</li>
                        </aside>
                    </section>
					<section>
						<h3>Generic Objects</h3>
						<img src="img/generic_objects.png" />
					</section>
					<section>
						<h3>Fixnum</h3>
						<img src="img/fixnum_object.png" />
						<aside class="notes">
							Symbol, NilClass, TrueClass, FalseClass has their owned flags.
						</aside>
					</section>
					<section>
						<h3>How do generic objects have instance variables?</h3>
						<img src="img/generic_iv_tbl.png" />
						<aside class="notes">
							All generic objects don't have their owned numiv and ivptr. Ruby saves it in a special hash called generic_iv_tbl. This hash maintains a map between generic objects and pointers to other hashes that contain each object’s instance variables.
						</aside>
					</section>
                    <section>
                        <h3>RClass</h3>
                        <img src="img/r_class.png" />
                        <aside class="notes">
                            <p>RClass: include/ruby/ruby.h:790</p>
                            <p>rb_classext_struct: internal.h:264</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Class Instance Variable Access</h3>
                        <img src="img/class_instance_variable.png" />
                    </section>
                    <section>
                        <h3>Class Variable Access</h3>
                        <img src="img/class_variable.png" />
                    </section>
                    <section>
                        <h3>Guess?</h3>
                        <pre><code class="ruby">
class SuperClass
end
class SubClass &lt; SuperClass
end

SubClass.class_variable_set :@@b, 'b'
SuperClass.class_variable_set :@@b, 'a'
SubClass.class_variable_set :@@b
                        </code></pre>
                    </section>
				</section>

                <section>
                    <section>
                        <h1>Method Lookup &amp; Constant Lookup</h1>
                    </section>
                    <section>
                        <h3>Module</h3>
                        <h4>There's no RModule in MRI</h4>
                    </section>
                    <section>
                        <img src="img/r_class_for_module.png" />
                    </section>
                    <section>
                        <h3>Include Module in a Class</h3>
                        <pre><code class="ruby">
module Professor
end

class Methematician &lt; Person
  include Professor
end
                        </code></pre>
                    </section>
                    <section>
                        <img src="img/include_a_module_in_class.png" />
                    </section>
                    <section>
                        <h3>Include one Module into Another</h3>
                        <img src="img/include_multi_modules_in_class.png" />
                    </section>
                    <section>
                        <h3>Prepend Module in a Class</h3>
                        <img src="img/prepend_module_in_class.png" />
                        <aside class="notes">
                            Why does this design so tricky? Why not make it just direct? If we call method on this class directly, we won't find it if it is defined in prepended module.
                        </aside>
                    </section>
                    <section>
                        <h3>Guess: Does it work?</h3>
                        <pre><code class="ruby">
module A
  def f
    'module A'
  end
end

class C
  include A
end

C.new.f
                        </code></pre>
                        <aside class="notes">
                            Works, <code>m_tbl</code> will be copyed but still share memory.
                        </aside>
                    </section>
                    <section>
                        <h3>Guess Again?</h3>
                        <pre><code class="ruby" style="max-height: inherit;">
module A
  def f
    'module A'
  end
end

module B
end

class C
  include B
end

module B
  include A
end

C.new.f
                        </code></pre>
                        <aside class="notes">
                            <p>No, <code>module B</code> has been copyed, it can't include module A in its copy.</p>
                            <p>rb_include_module: class.c:823</p>
                            <p>include_modules_at: class.c:848</p>
                            <p>rb_include_class_new: class.c:788</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Global Method Cache</h3>
                        <table style="margin: auto;">
                            <tr><th>klass</th><th>defined_class</th></tr>
                            <tr><td>Fixnum#times</td><td>Integer#times</td></tr>
                            <tr><td>Object#puts</td><td>BasicObject#puts</td></tr>
                            <tr><td>etc ...</td><td>etc ...</td></tr>
                        </table>
                    </section>
                    <section>
                        <h3>The Inline Method Cache</h3>
                        <img src="img/inline_method_cache.png" />
                        <aside class="notes">
                            <ul>
                                <li>Any possible method creation, importing or removing will clean all caches.</li>
                                <li>Since 2.1, invalid only sub-classes under effective class</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Lexical Scope</h3>
                        <img src="img/lexical_scope.png" />
                    </section>
                    <section>
                        <h3>Constant Access</h3>
                    </section>
                    <section>
                        <h3>Guess?</h3>
                        <pre><code class="ruby">
class SuperClass
  FIND_ME = "Found in SuperClass"
end

module ParentLexicalScope
  FIND_ME = "Found in ParentLexicalScope"

  class SubClass &lt; SuperClass
    p FIND_ME
  end
end
                        </code></pre>
                        <aside class="notes">
                            <ul>
                                <li>search through lexical scope chain</li>
                                <li>for each scope's class, check for autoload</li>
                                <li>search through superclass chain</li>
                                <li>for each superclass, check for autoload</li>
                                <li>call const_missing</li>
                            </ul>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Closure &amp; Binding</h1>
                    </section>
                    <section>
                        <h3>Block</h3>
                        <pre><code class="ruby">
10.times do
  str = "The quick brown fox jumps over the lazy dog."
  puts str
end
                        </code></pre>
                    </section>
                    <section>
                        <img src="img/rb_block_t_initialization.png" />
                        <aside class="notes">
                            <ul>
                                <li>Before call <code>times</code> method, Ruby creates and initializes a new <code>rb_block_t</code> structure to represent the block. Copy the current <code>EP</code> into it.</li>
                                <li>When <code>yield</code> is called, Ruby can access local variables directly from <code>rb_control_frame_t</code> structure, and access variables from the parent scope indirectly from <code>EP</code> in the block using dynamic variable access.
                                <li>rb_control_frame_t: vm_core.h:445</li>
                                <li>rb_block_t: vm_core.h:462</li>
                                <li>Ruby doesn't really allocate memory for and initialize <code>rb_block_t</code>, just references subset of <code>rb_control_frame_t</code>, that's why block is not really an Object.
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Lambda</h3>
                        <pre><code class="ruby">
def message_function
  str = "The quick brown fox"
  lambda do |animal|
    puts "#{str} jumps over the lazy #{animal}." 
  end
end

function_value = message_function
function_value.call 'dog'
                        </code></pre>
                    </section>
                    <section>
                        <h3>rb_lambda_t?</h3>
                    </section>
                    <section>
                        <h3>rb_proc_t</h3>
                        <aside class="notes">
                            <code>rb_proc_t</code> contains <code>rb_block_t</code>, means a proc is a kind of Ruby object that wraps up a block.
                        </aside>
                    </section>
                    <section>
                        <img src="img/rb_proc_t_initialization.png" />
                        <aside class="notes">
                            <ul>
                                <li>When you call lambda, Ruby copies the entire contents of the current YARV stack frame into the heap.</li>
                                <li><code>rb_env_t</code> is a wrapper for the heap copy of the stack.</li>
                                <li>When Ruby calls the block inside the proc, it copies the stack frame in the heap. The new stack frame contains an <code>EP</code> that points to the heap.</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Proc is an Object</h3>
                        <img src="img/rb_proc_t.png" />
                    </section>
                    <section>
                        <h3>Guess?</h3>
                        <pre><code class="ruby">
def message_function
  str = "The quick brown fox"
  func = lambda do |animal|
    puts "#{str} jumps over the lazy #{animal}." 
  end
  str = "The sly brown fox"
  func
end

function_value = message_function
function_value.call 'dog'
                        </code></pre>
                        <aside class="notes">
                            Once Ruby creates the new heap copy of the stack (the new <code>rb_env_t</code> structure or internal environment object), it resets the <code>EP</code> in the <code>rb_control_frame_t</code> structure to point to the copy.
                        </aside>
                    </section>
                    <section>
                        <h3>Binding</h3>
                        <pre><code class="ruby">
def get_binding
  a = 2
  b = 3
  binding
end

eval('puts a + b', get_binding)
                        </code></pre>
                    </section>
                    <section>
                        <h3>rb_binding_t</h3>
                        <img src="img/rb_binding_t_initialization.png" />
                        <aside class="notes">
                            As the implementation of *_eval, *_exec, <code>EP</code> in new rb_control_frame_t points to the lower stack frame. So Ruby can access to local variable directly.
                        </aside>
                    </section>
                    <section>
                        <img src="img/rb_binding_t.png" />
                    </section>
                </section>

                <section>
                    <section>
                        <h1>GC</h1>
                    </section>
                    <section>
                        <h3>Algorithms</h3>
                    </section>
                    <section>
                        <h3>MRI</h3>
                        <h4>mark-and-sweep garbage collection</h4>
                    </section>
                    <section>
                        <h3>RVALUE</h3>
                        <img src="img/first_memory_block_token.png" />
                        <aside class="notes">
                            <ul>
                                <li>RVALUE as a basic unit</li>
                                <li>RVALUE: gc.c:325</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Mark</h3>
                        <img src="img/mri_gc_marking.png" />
                        <aside class="notes">
                            MRI has marked five active objects (gray) with five garbage objects remaining in the heap (white).
                        </aside>
                    </section>
                    <section>
                        <h3>Since 2.0, Bitmap Marking</h3>
                        <img src="img/mri_gc_bitmap_marking.png" />
                        <aside class="notes">
                            Since 2.0, because of Unix memory optimization technique "copy on write" when fork.
                        </aside>
                    </section>
                    <section>
                        <h3>Sweeping</h3>
                        <img src="img/mri_gc_sweeping.png" />
                        <aside class="notes">
                            While sweeping, MRI places unused RVALUE structures back on the free list.
                        </aside>
                    </section>
                    <section>
                        <h3>Since 1.9.3, Lazy Sweeping</h3>
                        <aside class="notes">
                            <ul>
                                <li>Lazy sweeping sweeps only enough garbage objects back to the free list to create a few new Ruby objects and to allow your program to continue</li>
                                <li>Lazy sweeping can reduce the amount of time your program is paused waiting for garbage collection; however, it doesn’t reduce the overall amount of garbage collection work to do. Lazy sweeping amortizes the same total amount of sweeping work over multiple GC pauses.</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>JRuby &amp; Rubinius</h3>
                        <h4>copying garbage collection</h4>
                        <h4>generational garbage collection</h4>
                        <h4>concurrent garbage collection</h4>
                    </section>
                    <section>
                        <h3>Bump Allocation</h3>
                        <img src="img/gc_bump_allocation.png" />
                        <aside class="notes">
                            Copying garbage collection is the ability to create objects of different sizes
                        </aside>
                    </section>
                    <section>
                        <h3>The Semi-Space Algorithm</h3>
                        <img src="img/gc_semi_space_algorithm.png" />
                    </section>
                    <section>
                        <h3>Generational Garbage Collection</h3>
                        <img src="img/gc_promote_old_objects.png" />
                        <aside class="notes">
                            JRuby &amp; Rubinius have used it for years. Intrduced into MRI since 2.1.
                            <ul>
                                <li>Keywords: minor GC, major GC</li>
                                <li>Popular Algorithms combination: minor: Copy, major: Mark &amp; Sweep</li>
                                <li>MRI 2.1: both Mark &amp; Sweep</li>
                                <li>Promotion: Rubinius: 2, MRI 2.1: 1(limited by Mark &amp; Sweep), JRuby: dynamic</li>
                                <li>JRuby: another "permanent generation" for internal objects for JVM ifself</li>
                                <li>Rubinius: Also uses a third generation for very large objects by Mark &amp; Sweep</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Since 2.1, RGenGC</h3>
                        <h4>Restricted Generational Garbage Collection</h4>
                        <img src="img/generational_gc_problem.png" />
                    </section>
                    <section>
                        <h3>Write barries</h3>
                        <img src="img/gc_write_barries.png" />
                        <aside class="notes">
                            Ruby 2.1 uses an old GC technique called write barriers to monitor changes to mature objects – whenever you add a reference from one object to another (whenever you write to or modify an object), a write barrier is triggered. The barriers check whether the source object is mature, and if so adds the mature object to a special list. Later Ruby 2.1 includes these just these modified mature objects in the next mark and sweep process, preventing active, young objects from being incorrectly considered garbage.
                        </aside>
                    </section>
                    <section>
                        <h3><a href="http://www.ustream.tv/recorded/35107339/highlight/377033">
                            Koichi’s fascinating presentation from EuRuKo 2013
                        </a></h3>
                        <aside class="notes">
                            Difficult to implement WB in C-ext, watch the video for more details!
                        </aside>
                    </section>
                    <section>
                        <h3>Concurrect Garbage Collection</h3>
                        <aside class="notes">
                            <ul>
                                <li>Run GC on separate thread</li>
                                <li>Since 2.1, MRI reduce sweeping time by introducing this tech</li>
                            </ul>
                        </aside>
                    </section>
                    <section>
                        <h3>Marking While the Object Graph Changes</h3>
                        <img src="img/gc_concurrent_gc_problem.png" />
                        <aside class="notes">
                            New object hasn't been marked here, so it'll be GCed!
                        </aside>
                    </section>
                    <section>
                        <h3>Tricolor Marking</h3>
                        <img src="img/gc_tricolor_marking.png" />
                        <aside class="notes">
                            <ul>
                                <li>White: haven't been marked, all objects start from here.</li>
                                <li>Grey: reachable, but we still need to check any objects that the object references</li>
                                <li>Black: marked, have no references to objects in the white set, surely won't be GCed</li>
                                <li>Pick an object from the grey set. Blacken this object (move it to the black set), by greying all the white objects it references directly</li>
                                <li>Repeat the previous step until the grey set is empty</li>
                                <li>When there are no more objects in the grey set, then all the objects remaining in the white set will be GCed</li>
                                <li style="color: red">The collector moves a marked object back to the mark stack because the application modified it.</li>
                                <li style="color: red">Write barriers are used by both generational and concurrent garbage collectors.</li>
                            </ul>
                        </aside>
                    </section>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
