<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Ruby Hacker, Happy Hacker</title>
		<meta name="description" content="Ruby under a microscope introduction">
		<meta name="author" content="Bachue Zhou">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Ruby Hacker</h1>
					<h3>Happy Hacker</h3>
					<p>
						<small>Created by <a href="http://bachue.is-programmer.com">Bachue</a> / <a href="http://twitter.com/iBachue">@iBachue</a></small>
					</p>
          <aside class="notes">
            <div>本Slides从 Rails ActiveSupport 库中采集大量有意思的Hack例子并为大家讲解，主要是让大家对 Ruby 元编程的代码和效果有个初步的印象。虽然源于 Rails 却并没有照搬照抄 Rails 的实现，一方面是为了便于讲解，省去大量无意义的细节，一方面也觉得 Rails 的实现也并非完美，也不够有趣，而且 Rails 4 为了考虑到兼容性，没有使用很多 Ruby 新版本的特性。</div>
          </aside>
				</section>

				<section>
					<section>
						<h1>Elegant Inquery</h1>
              <aside class="notes">
                <div>首先，让我们从一个最简单的例子开始吧！</div>
              </aside>
					</section>
					<section>
            <h3>Rails.env</h3>
            <pre><code class="ruby">
Rails.env == "production"
            </code></pre>
            <aside class="notes">
              <div>在Rails中，有一个环境变量 Rails.env 用来表示当前Rails跑在哪种环境中，一般来说，总共有三种环境：</div>
              <ul>
                <li>Development</li>
                <li>Test</li>
                <li>Production</li>
              </ul>
              <div>当我们需要判断当前 Rails 执行在哪种环境中时，我们可以用这样的匹配方法</div>
            </aside>
          </section>
          <section>
            <h3>Rails.env</h3>
            <pre><code class="ruby">
Rails.env.production?
            </code></pre>
            <aside class="notes">
              <div>当然 Rails 程序员不喜欢这种写法，他们更倾向于这样更有 Ruby 风格的写法</div>
            </aside>
          </section>
          <section>
            <h3>How to Implement?</h3>
            <aside class="notes">
              <div>那么如何实现这种写法呢？</div>
              <div>当然，依次定义<code>production?</code>,<code>development?</code>, <code>test?</code>是可以的，但是有没有更加通用的办法？</div>
            </aside>
          </section>
          <section>
            <h3>method_missing</h3>
            <pre><code class="ruby">
class StringInquirer &lt; String
  private def method_missing method_name, *arguments
    if method_name[-1] == '?'
      self == method_name[0..-2]
    else
      super
    end
  end
end
            </code></pre>
            <aside class="notes">
              <div>在 Ruby 中，任何找不到的方法都会调用 method_missing 方法去解决，这个方法的默认实现总是抛出 NoMethodError 错误，当然你可以覆盖它。</div>
              <div>在这里，我们先继承了String类型，由于String的子类可以表现的和它的父类一模一样，因此人们不会注意到 Rails.env 其实返回了另一个类型的实例。然后在这个子类中重写 method_missing 方法，判断找不到的那个方法是否以问号结尾，如果是，将方法名中问号之前的部分取出，与自身做对比，如果不是，调用父类的默认实现，也就是抛出 NoMethodError 错误即可。</div>
            </aside>
          </section>
          <section>
            <h3>method_missing</h3>
            <pre><code class="ruby">
class StringInquirer &lt; String
  private def respond_to_missing? method_name, include_private = false
    method_name[-1] == '?'
  end
end

Rails.env.respond_to? :development? # =&gt; true
            </code></pre>
            <aside class="notes">
              <div>单这样实现还可能有个疏漏，Ruby 允许调用<code>respond_to?</code>方法查询一个方法名是否存在，单单只有<code>method_missing</code>的实现会使得这个查询会失败，因此，Ruby 提供了一个专门用于覆盖的方法<code>respond_to_missing?</code>，它的返回值将影响<code>respond_to?</code>的结果。在这里，我们写成任何以问号结尾的方法总是能查询成功。</div>
            </aside>
          </section>
				</section>

				<section>
					<section>
						<h1>Elegant Time</h1>
            <aside class="notes">
              <div>第二个例子来自于 Rails 的优雅的时间计算</div>
            </aside>
          </section>
          <section>
						<h3>Elegant Time</h3>
            <pre><code class="ruby">
1.day.ago # =&gt; 2014-08-11 22:41:47 +0800
1.day - 2.hours # =&gt; 22 hours
            </code></pre>
            <aside class="notes">
              <div>这是 Rails 中一个十分经典的例子，连 Matz 也表示这样的设计令人震惊。</div>
              <div><code>1.day.ago</code>返回一天前的时间，而<code>1.day</code>，<code>2.hours</code>都是可以相互做数学运算的。</div>
            </aside>
          </section>
          <section>
						<h3>How to Implement?</h3>
              <pre><code class="ruby" style="max-height: inherit;">
class Numeric
  def seconds
    self
  end
  alias second seconds

  def minutes
    self * 60
  end
  alias minute minutes

  def hours
    self * 60.minutes
  end
  alias hour hours

  def days
    self * 24.hours
  end
  alias day days

  def ago
    Time.now - self
  end
end
            </code></pre>
            <aside class="notes">
              <div>这也许是一个大家都能最先想到的实现方法，在 Ruby 中，所有的类都是开放的，可以随时修改的，即使是内部类也不例外。</div>
              <div>这个代码已经能实现时间计算的基本功能了，但是还存在三个问题：</div>
              <ul>
                <li>1. 用户可以调用<code>1.ago</code>，返回前一秒的时间，虽然并没有逻辑错误，但是语意是不对的，不熟悉的人可能无法理解这个写法。</li>
                <li>2. 用户可以调用<code>1.hour.hour</code>，不仅语义奇怪而且返回值也难以理解。</li>
                <li>3. 案例中的<code>1.day - 2.hours</code>返回 22 hours 这样的功能没有实现，在 Ruby 中，覆盖<code>inspect</code>方法可以修改这个返回值，当然你不能让所有数字以后都返回成这样的样子，即使那些数字并不表示时间。</li>
              </ul>
              <div>也许大家很容易想到在第一个例子中我们对于字符串采用的办法，先创造一个子类，然后在子类上实现我们所需要的功能。不过这个办法对数字无效，因为数字是一个基本类型，并没有设计可以传入自身值的构造方法，事实上，数字是不能像对象一样在不改变内存地址的前提下改变自身状态的。</div>
            </aside>
          </section>
          <section>
						<h3>BlankSlate</h3>
              <pre><code class="ruby">
class BlankSlate &lt; BasicObject
  undef_method :==
  undef_method :equal?
end
              </code></pre>
						<aside class="notes">
              <div>在这里，我们采用的方法是代理。首先，创造一个几乎没有实现任何方法的 BlankSlate 类。在 Ruby 中，绝大多数类原生就实现了大量方法，即使是 Object 类，也实现了55个方法，这样的类是不能做代理的。幸运的是，Ruby 还有一个比 Object 更基础的类，仅仅实现了必要方法的 BasicObject，这个类在平时不太常用，但是作为 BlankSlate 的基类是十分合适的，只要在 BasicObject 的基础上再移除两个方法即可。</div>
						</aside>
					</section>
          <section>
            <h3>Proxy</h3>
            <pre><code class="ruby" style="max-height: inherit;">
class Duration &lt; BlankSlate
  def initialize proxy
    @proxy = proxy
  end

  def + other
    ::Duration.new @proxy + other
  end

  def - other
    ::Duration.new @proxy - other
  end

  def -@
    ::Duration.new -@proxy
  end

  def ago
    ::Time.now - @proxy
  end

  private def method_missing method, *args, &amp;block
    @proxy.send method, *args, &amp;block
  end
end
            </code></pre>
            <aside class="notes">
              <div>有了 BlankSlate 类，创建它的子类并且定义具有转发功能的<code>method_missing</code>方法即可，由于 BlankSlate 几乎没有实现任何方法，所以几乎总会调用到<code>method_missing</code>，并让被托管的对象来做具体的事情。考虑到实现难度，我们暂时不设计一个无比优雅的Ruby风格的DSL来实现托管功能。</div>
              <div>由于数字的运算总是返回数字，而我们希望 Duration 类的实例与数字的计算还是返回一个 Duration 的实例，因此我们覆盖了<code>+</code>，<code>-</code>和负数的运算实现（这里需要注意 Ruby 是支持运算符重载的），然后把<code>ago</code>的实现搬过来，这样<code>1.ago</code>就会返回 NoMethodError 错误而<code>1.day.ago</code>还能正确运行了。</div>
            </aside>
          </section>
          <section>
            <h3>Numeric</h3>
            <pre><code class="ruby" style="max-height: inherit;">
class Numeric
  def seconds
    Duration.new self
  end
  alias second seconds

  def minutes
    Duration.new(self * 60)
  end
  alias minute minutes

  def hours
    Duration.new(self * 60.minutes)
  end
  alias hour hours

  def days
    Duration.new(self * 24.hours)
  end
  alias day days
end
            </code></pre>
            <aside class="notes">
              <div>修改后的Numeric类</div>
            </aside>
          </section>
          <section>
            <h3>Question?</h3>
            <p>How to avoid <code>1.hour.hour</code>?</p>
            <aside class="notes">
              <div>现场提问：上述代码还没有解决前面提到的<code>1.hour.hour</code>依然可以执行的问题，为什么？如何解决？</div>
              <div>答案：由于Duration将<code>hour</code>方法转发给了Numeric对象，因此依然可以调用<code>hour</code>方法，解决方案是在<code>method_missing</code>里增加判断语句，阻止转发。</div>
            </aside>
          </section>
          <section>
            <h3>inspect</h3>
            <pre><code class="ruby" style="max-height: inherit;">
class Duration
  def inspect
    value = @proxy
    parts = %w[days hours minutes seconds].inject([]) do |units, unit|
      if value &gt;= 1.send(unit)
        quotient, value = value.divmod 1.send(unit)
        units + [[quotient, unit]]
      else
        units
      end
    end
    parts.map! {|value, unit| "#{value} #{value == 1 ? unit.chop : unit}" }
    parts.join(', ')
  end
end
            </code></pre>
            <aside class="notes">
              <div>至于让<code>1.day - 2.hours</code>返回 22 hours，只要覆盖<code>inspect</code>方法即可，这里有个简易实现（这个实现是有缺陷的，没有考虑值为0和负数的情况，也没有去实现本地化，只是为了让大家有个概念而已。这个实现也并非来自Rails，事实上Rails采用的算法更简陋）</div>
            </aside>
          </section>
        </section>
        <section>
					<section>
						<h3>Module Include &amp; Extend</h3>
						<pre><code class="ruby">
class C
  include M
  extend M::ClassMethods
end
						</code></pre>
						<aside class="notes">
              <div>在现有的 Ruby 中，让一个 Module 既能为一个类添加事例方法，也能添加类方法并不容易，因为这在 Ruby 中是两种不同操作，<code>include</code>将模块中的方法作为实例方法载入，而<code>extend</code>将方法作为类方法载入，这需要调用两种不同方法才能实现。如果还希望模块在被包含后能调用类方法做些初始化工作就更加困难了。</div>
						</aside>
					</section>
          <section>
            <h3>Module Include &amp; Extend</h3>
            <pre><code class="ruby">
module M
  def self.included(base)
    base.extend ClassMethods
    base.class_eval do
      scope :disabled, -&gt; { where(disabled: true) }
    end
  end
  module ClassMethods
    # ...
  end
end
            </code></pre>
            <aside class="notes">
              <div>可以看到，要实现这些，模块必须重定义自身的<code>included</code>方法，当任何类包含这个模块的时候，<code>included</code>方法将被回调，并传入包含它的类作为参数，<code>included</code>随后调用类的<code>extend</code>方法将定义类方法的模块也包含进去，然后调用该类的<code>class_eval</code>或者<code>class_exec</code>方法才能在类上执行一些代码。</div>
            </aside>
          </section>
          <section>
            <h3>Concern</h3>
            <pre><code class="ruby">
module M
  extend Concern
  included do
    scope :disabled, -&gt; { where(disabled: true) }
  end
  module ClassMethods
    # ...
  end
end
            </code></pre>
            <aside class="notes">
              <div>Rails 对于这个问题，定义了一个 Concern 模块，当一个模块<code>extend</code>这个模块的时候，那么任何对于这个模块的包含都会自动添加该模块下<code>ClassMethods</code>的方法作为类方法，还能回调传入<code>included</code>的block。相当厉害吧！</div>
            </aside>
          </section>
          <section>
            <h3>How to Implement?</h3>
            <pre><code class="ruby" style="max-height: inherit;">
module Concern
  def self.extended base
    base.instance_variable_set(:@_dependencies, [])
  end

  def included base = nil, &amp;block
    if base.nil?
      @_included_blocks ||= [] # Initialize
      @_included_blocks &lt;&lt; block
    else
      super
    end
  end

  def append_features base
    if base.instance_variable_defined?(:@_dependencies)
      base.instance_variable_get(:@_dependencies) &lt;&lt; self
      return false
    else
      return false if base &lt; self
      @_dependencies.each { |dep| base.send(:include, dep) }
      super
      base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
      if instance_variable_defined?(:@_included_blocks)
        @_included_blocks.each {|block| base.class_eval(&amp;block) }
      end
    end
  end
end
            </code></pre>
            <aside class="notes">
              <div>当 Concern 被 extend 的时候，Concern 本身的<code>extended</code>方法将被回调，这和<code>included</code>是类似的。<code>extended</code>在 extend 它的类上添加了一个类实例变量<code>@_dependencies</code>数组用以记录依赖，当一个<code>extend</code>Concern的模块包含另一个<code>extend</code>了 Concern 的模块时，这个变量会将该模块记录为依赖。然后，当有类包含这个模块的时候，<code>append_features</code>将会被回调，所有依赖的模块都将被<code>include</code>进去。</div>
              <div><code>super</code>将调用<code>append_features</code>的默认实现，完成<code>include</code>一个模块的主要工作。</div>
              <div>如果该模块包含一个叫<code>ClassMethods</code>的子模块，就会被<code>extend</code>进去，这样里面的方法就成为了类的类方法。</div>
              <div><code>included</code>原本是 Module 本身的回调函数，Concern 覆盖了其实现，使得它还可以接受一个block，<code>included</code>记录每一个 block，当模块被包含的时候，所有 block 都将被传入类的 class_eval 执行。</div>
            </aside>
          </section>
          <section>
            <h3>class_eval</h3>
            <h3>module_eval</h3>
            <h3>instance_eval</h3>
            <aside class="notes">
              <div>Ruby 分<code>class_eval</code>，<code>module_eval</code>和<code>instance_eval</code>，都代表在上下文环境内执行一段代码，其中<code>class_eval</code>将代码在类环境下执行，<code>module_eval</code>将代码在 Module 环境下执行，<code>instance_eval</code>将方法在实例环境下执行。</div>
              <div>只有类和 Module 才拥有<code>class_eval</code>和<code>module_eval</code>方法，在里面执行代码和将代码写在他们的类定义里是等效的，比如说，如果你在里面定义的方法就会被当做实例方法的定义。而<code>instance_eval</code>所有实例都有，连类也有，因为类也是 Class 类的对象嘛。在里面执行代码相当于在它的 singleton_class 里执行代码，如果你在一个类的<code>instance_eval</code>里定义方法就会被当做类方法。</div>
            </aside>
          </section>
        </section>
<!--         <section>
          <section>
            <h1>Elegant Time</h1>
            <aside class="notes">
              <div>第二个例子来自于 Rails 的优雅的时间计算</div>
            </aside>
          </section>
        </section>
 -->        <section>
            <h1>Thanks!</h1>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
